var fs        = require('fs'),
    del       = require('del'),
    gulp      = require('gulp'),
    gbump     = require('gulp-bump'),
    gjshint   = require('gulp-jshint'),
    ggit      = require('gulp-git'),
    gmocha    = require('gulp-mocha'),
    gshell    = require('gulp-shell')
    gsize     = require('gulp-size'),
    gutil     = require('gulp-util'),
    gwebpack  = require('gulp-webpack'),
    path      = require('path'),
    webpack   = require('webpack'),
    uglify    = require('uglify-js');

var paths = {    
  ENTRY:    './index.js',
  FILE:     'mmeddle.js',
  FILE_MIN: 'mmeddle.min.js',
  FILE_MAP: 'mmeddle.map',
  HEADER:   './src/header.js',
  VERSION:  './src/version.js',
  DIST:     './dist',
  REF_SRC:  './src/function/',
  REF_DEST: './docs/reference/functions/',
  NODE_BIN: './node_modules/.bin',

  images:  'images/**/*',
  src:     ['index.js', 'src/**/*.js'],
  allsrc:  ['test/**/*.js', '!test/libs/*.js', 'index.js', 'src/**/*.js'],
  lintsrc: ['test/**/*.js', '!test/libs/*.js', 'index.js', 'src/**/*.js'
           , 'testm/**/*.js', 'scratch/**/*.js'],
  tests:   ['test/**/*.js']
};

var pkg = require('./package.json');
var disableMinify = false;

paths.MMEDDLE_JS     = path.join(paths.DIST, paths.FILE);
paths.MMEDDLE_MIN_JS = path.join(paths.DIST, paths.FILE_MIN);
paths.MMEDDLE_MAP_JS = path.join(paths.DIST, paths.FILE_MAP);

var g_banner = false;
var g_versionUpdated = false;
    
// Make package.json script commands into windows/unix compatible
// shell commands that are found in the ./node_modules/.bin directory.
function nodeBin(cmd) {
 var cmdParts = cmd.split(' ');
 var cmdPath = path.join(paths.NODE_BIN, cmdParts[0]);
 cmdParts[0] = path.normalize(cmdPath);
 return cmdParts.join(' ');
}

// generate banner with today's date and correct version
function createBanner() {
  // Create the new banner only once.
  if (!g_banner) {
    var today = gutil.date(new Date(), 'yyyy-mm-dd'); // today, formatted as yyyy-mm-dd
    var version = pkg.version;
    gutil.log('createBanner:' + paths.MMEDDLE_JS);
    g_banner = String(fs.readFileSync(paths.HEADER))
        .replace('@@date', today)
        .replace('@@version', version);
  }
  return g_banner;
}

// generate a js file containing the version number
function updateVersionFile() {
  if (g_versionUpdated) {
    return;
  }
  
  gutil.log('updateVersionFile:' + paths.MMEDDLE_JS);
  var version = pkg.version;
  // generate file with version number
  fs.writeFileSync(paths.VERSION, 'module.exports = \'' + version + '\';\n' +
      '// Note: This file is automatically generated when building mmeddle.js.\n' +
      '// Changes made in this file will be overwritten.\n');
  g_versionUpdated = true;
}

function bundle() {
  // update the banner contents (has a date in it which should stay up to date)
  gutil.log('bundle:' + paths.MMEDDLE_JS);
  var banner = createBanner();
  var bannerPlugin = new webpack.BannerPlugin(banner, {
    entryOnly: true,
    raw: true
  });

  bannerPlugin.banner = banner;
  updateVersionFile();
  return gulp.src(paths.ENTRY)
    .pipe(gwebpack({
        output: {
          library: 'mmeddle',
          libraryTarget: 'umd',
          filename: paths.FILE
        },
        externals: [
          // 'crypto' is referenced by decimal.js
        ],
        plugins: [ bannerPlugin ],
        cache: true
      }, null,
      function(err, stats) {
        if (err) {
          gutil.log('******************NOT bundled ' + paths.MMEDDLE_JS);
          gutil.log(err);
        }
        gutil.log('bundled ' + paths.MMEDDLE_JS);
      }))
    .pipe(gsize({ title: "Full source browser script: " + paths.MMEDDLE_JS }))
    .pipe(gulp.dest(paths.DIST));
}

gulp.task('bundle', ['validate', 'test'], function () {
  return bundle();
});

gulp.task('minify', ['bundle'], function () {
  if (!disableMinify) {
    var result = uglify.minify([paths.MMEDDLE_JS], {
        outSourceMap: paths.FILE_MAP,
        output: {
          comments: /@license/
        }
      });
    fs.writeFileSync(paths.MMEDDLE_MIN_JS, result.code);
    fs.writeFileSync(paths.MMEDDLE_MAP_JS, result.map);
    gutil.log('Minified ' + paths.MMEDDLE_MIN_JS);
    gutil.log('Mapped ' + paths.MMEDDLE_MAP_JS);
    return gulp.src(paths.MMEDDLE_MIN_JS)
        .pipe(gsize({ title: "Minimized browser script: " + paths.MMEDDLE_MIN_JS }));
  }
});

// test various item for consistency
gulp.task('validate', function (cb) {
  gutil.log('validate:' + paths.MMEDDLE_JS);
  // A no-op for now.
  gutil.log('validated:' + paths.MMEDDLE_JS);
  cb();
});

function doLint(cb) {
  gulp.src(paths.lintsrc)
      .pipe(gjshint('.jshintrc'))
      .pipe(gjshint.reporter('jshint-stylish'));
  gutil.log(gutil.colors.green(' JSHINT  *completed*'));
  cb();
}

// Wrapper to run Lint by itself.
gulp.task('lint', [], doLint);

// Wrapper to run test with name testm.
gulp.task('testm', ['test']);

// Run the PhantomJS browser based tests a bit indirectly.
gulp.task('testb', ['bundle', 'minify'], gshell.task([
  nodeBin(pkg.scripts.testb)
]));

// Run the PhantomJS browser based tests a bit indirectly.
gulp.task('testmb', ['testm'], function() {
  return bundle()
    .pipe(gshell([ nodeBin(pkg.scripts.testb) ]));
});

// Run Mocha tests on all test.*js files.
gulp.task('test', ['lint'], function () {
    return gulp.src(paths.tests, {read: false})
        .pipe(gmocha({
          ui: 'bdd',
          //reporter: 'nyan'
          //reporter: 'progress'
          //reporter: 'dot'
          //reporter: 'min' 
          //reporter: 'spec'
          reporter: 'list'
        }));
});  

gulp.task('clean', function (cb) {
  del([path.join(paths.DIST, '*')], function(err, deletedFiles) {
    if (deletedFiles.length > 0) {
      gutil.log('Files deleted:', deletedFiles.join(', '));
    }
    else {
      gutil.log('No files deleted.');
    }
    cb();
  });
});

gulp.task('bump', function () {
  return gulp.src(['./package.json', './bower.json'])
    .pipe(gbump())
    .pipe(gulp.dest('./'));
});

// Commit, tag and push changes to the master branch in GitHub.
gulp.task('commit-tag-push', function () {
  var version = pkg.version;
  var v = 'v' + version;
  var message = 'Release ' + v; 
  
  // Make the message more interesting using an environment variable.
  if (process.env.GIT_COMMIT_MESSAGE) {
    message += ' - ' + process.env.GIT_COMMIT_MESSAGE;
  }

  gutil.log('Commit Tag and Push as: "' + message + '"');
  return gulp.src('./')
    .pipe(ggit.commit(message))
    .pipe(ggit.tag(v, message))
    .pipe(ggit.push('origin', 'master', '--tags'))
    .pipe(gulp.dest('./'));
});

// Publish the package to NPM.
gulp.task('npm', function (done) {
  require('child_process').spawn(
    'npm',
      ['publish'], { stdio: 'inherit' }
    ).on('close', done);
});

// Run the Istanbul code coverage reporter based on the mocha tests.
gulp.task('coverage', gshell.task([
  nodeBin(pkg.scripts.coverage)
]));

gulp.task('docs', gshell.task([
  nodeBin(pkg.scripts.docs)
]));

// Open generated web pages 
gulp.task('showcoverage', gshell.task([
  path.join('.', 'coverage', 'lcov-report', 'index.html')
], { ignoreErrors: true }));

gulp.task('showdocs', gshell.task([
  path.join('.', 'docs', 'src', 'index.html')
], { ignoreErrors: true }));

// The default task (called when you run `gulp`)
gulp.task('default', ['testm', 'bundle', 'minify'], gshell.task([
  'echo ---------- Generating javadocs ----------',
  nodeBin(pkg.scripts.docs)
]));

// Watch task to automatically test and lint when the source code changes
gulp.task('watch', ['minify'], function () {
  // Just do tests while watching.
  gulp.watch(paths.allsrc, ['testm']);
});

// Watch to automatically test, lint, then build and test in browser.
gulp.task('watchb', ['testm', 'bundle'], function () {
  // Just do tests while watching.
  gulp.watch(paths.allsrc, ['testmb']);
});
